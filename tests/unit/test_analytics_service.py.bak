"""Unit tests for analytics_service module."""

import pytest
from datetime import UTC, datetime, timedelta

from src.core.db_client import RecordNotFoundError
from src.domain.chore import ChoreState
from src.domain.user import UserStatus
from src.services import analytics_service


@pytest.fixture
def patched_analytics_db(monkeypatch, in_memory_db):
    """Patches src.core.db_client functions to use InMemoryDBClient."""

    # Patch all db_client functions
    monkeypatch.setattr("src.core.db_client.create_record", in_memory_db.create_record)
    monkeypatch.setattr("src.core.db_client.get_record", in_memory_db.get_record)
    monkeypatch.setattr("src.core.db_client.update_record", in_memory_db.update_record)
    monkeypatch.setattr("src.core.db_client.delete_record", in_memory_db.delete_record)
    monkeypatch.setattr("src.core.db_client.list_records", in_memory_db.list_records)
    monkeypatch.setattr("src.core.db_client.get_first_record", in_memory_db.get_first_record)
    monkeypatch.setattr("src.core.db_client.RecordNotFoundError", RecordNotFoundError)

    return in_memory_db


@pytest.fixture
def sample_users():
    """Sample user data for testing."""
    return [
        {"id": "user1", "name": "Alice", "status": UserStatus.ACTIVE},
        {"id": "user2", "name": "Bob", "status": UserStatus.ACTIVE},
        {"id": "user3", "name": "Charlie", "status": UserStatus.ACTIVE},
    ]


@pytest.fixture
def sample_chores():
    """Sample chore data for testing."""
    now = datetime.now(UTC)
    return [
        {
            "id": "chore1",
            "title": "Chore 1",
            "assigned_to": "user1",
            "current_state": ChoreState.TODO,
            "deadline": (now + timedelta(days=1)).isoformat(),
        },
        {
            "id": "chore2",
            "title": "Chore 2",
            "assigned_to": "user2",
            "current_state": ChoreState.PENDING_VERIFICATION,
            "deadline": (now + timedelta(days=2)).isoformat(),
        },
        {
            "id": "chore3",
            "title": "Chore 3",
            "assigned_to": "user1",
            "current_state": ChoreState.TODO,
            "deadline": (now - timedelta(days=1)).isoformat(),  # Overdue
        },
    ]


@pytest.mark.unit
class TestGetLeaderboard:
    """Tests for get_leaderboard function."""

    async def test_empty_leaderboard(self, patched_analytics_db):
        """Test leaderboard when no completions exist."""
        result = await analytics_service.get_leaderboard(period_days=30)

        assert result == []

    async def test_single_user_completions(self, patched_analytics_db, sample_users):
        """Test leaderboard with one user having completions."""
        # Create user
        user = await patched_analytics_db.create_record("users", {"name": "Alice", "status": UserStatus.ACTIVE})

        # Create completion logs
        cutoff_date = datetime.now(UTC) - timedelta(days=15)
        for _ in range(3):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": user["id"],
                    "action": "claimed_completion",
                    "timestamp": (cutoff_date + timedelta(days=1)).isoformat(),
                }
            )

        result = await analytics_service.get_leaderboard(period_days=30)

        assert len(result) == 1
        assert result[0]["user_id"] == user["id"]
        assert result[0]["user_name"] == "Alice"
        assert result[0]["completion_count"] == 3

    async def test_multiple_users_sorted_descending(self, patched_analytics_db, sample_users):
        """Test leaderboard with multiple users sorted by completion count."""
        # Create users
        user1 = await patched_analytics_db.create_record("users", {"name": "Alice", "status": UserStatus.ACTIVE})
        user2 = await patched_analytics_db.create_record("users", {"name": "Bob", "status": UserStatus.ACTIVE})
        user3 = await patched_analytics_db.create_record("users", {"name": "Charlie", "status": UserStatus.ACTIVE})

        # Create completion logs (user2 has most, user1 has mid, user3 has least)
        cutoff_date = datetime.now(UTC) - timedelta(days=15)

        # User 2: 5 completions
        for _ in range(5):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": user2["id"],
                    "action": "claimed_completion",
                    "timestamp": (cutoff_date + timedelta(days=1)).isoformat(),
                }
            )

        # User 1: 3 completions
        for _ in range(3):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": user1["id"],
                    "action": "claimed_completion",
                    "timestamp": (cutoff_date + timedelta(days=1)).isoformat(),
                }
            )

        # User 3: 1 completion
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": user3["id"],
                "action": "claimed_completion",
                "timestamp": (cutoff_date + timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_leaderboard(period_days=30)

        assert len(result) == 3
        # Sorted descending by completion count
        assert result[0]["user_id"] == user2["id"]
        assert result[0]["completion_count"] == 5
        assert result[1]["user_id"] == user1["id"]
        assert result[1]["completion_count"] == 3
        assert result[2]["user_id"] == user3["id"]
        assert result[2]["completion_count"] == 1

    async def test_period_days_filtering(self, patched_analytics_db):
        """Test that leaderboard only includes completions within the period."""
        # Create user
        user = await patched_analytics_db.create_record("users", {"name": "Alice", "status": UserStatus.ACTIVE})

        now = datetime.now(UTC)

        # Create logs: 2 within period, 1 outside period
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": user["id"],
                "action": "claimed_completion",
                "timestamp": (now - timedelta(days=10)).isoformat(),  # Within 30 days
            }
        )
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": user["id"],
                "action": "claimed_completion",
                "timestamp": (now - timedelta(days=20)).isoformat(),  # Within 30 days
            }
        )
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": user["id"],
                "action": "claimed_completion",
                "timestamp": (now - timedelta(days=40)).isoformat(),  # Outside 30 days
            }
        )

        result = await analytics_service.get_leaderboard(period_days=30)

        assert len(result) == 1
        assert result[0]["completion_count"] == 2  # Only 2 within period

    async def test_missing_user_skipped_with_warning(self, patched_analytics_db):
        """Test that completions for missing users are skipped."""
        # Create log for non-existent user
        now = datetime.now(UTC)
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": "nonexistent_user",
                "action": "claimed_completion",
                "timestamp": (now - timedelta(days=10)).isoformat(),
            }
        )

        result = await analytics_service.get_leaderboard(period_days=30)

        # Should be empty since user doesn't exist
        assert result == []


@pytest.mark.unit
class TestGetCompletionRate:
    """Tests for get_completion_rate function."""

    async def test_zero_completions(self, patched_analytics_db):
        """Test completion rate with no completions."""
        result = await analytics_service.get_completion_rate(period_days=30)

        assert result["total_completions"] == 0
        assert result["on_time"] == 0
        assert result["overdue"] == 0
        assert result["on_time_percentage"] == 0.0
        assert result["overdue_percentage"] == 0.0
        assert result["period_days"] == 30

    async def test_multiple_completions(self, patched_analytics_db):
        """Test completion rate with multiple completions."""
        # Create approval logs (MVP counts all as on-time)
        now = datetime.now(UTC)

        for i in range(5):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": f"user{i}",
                    "action": "approve_verification",
                    "timestamp": (now - timedelta(days=5)).isoformat(),
                }
            )

        result = await analytics_service.get_completion_rate(period_days=30)

        assert result["total_completions"] == 5
        assert result["on_time"] == 5  # MVP counts all as on-time
        assert result["overdue"] == 0
        assert result["on_time_percentage"] == 100.0
        assert result["overdue_percentage"] == 0.0

    async def test_period_filtering(self, patched_analytics_db):
        """Test that only completions within period are counted."""
        now = datetime.now(UTC)

        # Create logs: 3 within period, 2 outside
        for i in range(3):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": f"user{i}",
                    "action": "approve_verification",
                    "timestamp": (now - timedelta(days=10)).isoformat(),
                }
            )

        for i in range(2):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": f"user{i+3}",
                    "action": "approve_verification",
                    "timestamp": (now - timedelta(days=40)).isoformat(),
                }
            )

        result = await analytics_service.get_completion_rate(period_days=30)

        assert result["total_completions"] == 3  # Only within period

    async def test_custom_period_days(self, patched_analytics_db):
        """Test completion rate with custom period."""
        now = datetime.now(UTC)

        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": "user1",
                "action": "approve_verification",
                "timestamp": (now - timedelta(days=5)).isoformat(),
            }
        )

        result = await analytics_service.get_completion_rate(period_days=7)

        assert result["total_completions"] == 1
        assert result["period_days"] == 7


@pytest.mark.unit
class TestGetOverdueChores:
    """Tests for get_overdue_chores function."""

    async def test_no_overdue_chores(self, patched_analytics_db):
        """Test when there are no overdue chores."""
        # Create chore with future deadline
        now = datetime.now(UTC)
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Future Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.TODO,
                "deadline": (now + timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_overdue_chores()

        assert result == []

    async def test_overdue_chores_past_deadline(self, patched_analytics_db):
        """Test finding chores past their deadline."""
        now = datetime.now(UTC)

        # Overdue chore
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Overdue Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.TODO,
                "deadline": (now - timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_overdue_chores()

        assert len(result) == 1
        assert result[0]["title"] == "Overdue Chore"

    async def test_completed_chore_not_overdue(self, patched_analytics_db):
        """Test that completed chores are not considered overdue."""
        now = datetime.now(UTC)

        # Completed chore with past deadline
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Completed Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.COMPLETED,
                "deadline": (now - timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_overdue_chores()

        assert result == []

    async def test_filter_by_user_id(self, patched_analytics_db):
        """Test filtering overdue chores by user ID."""
        now = datetime.now(UTC)

        # User1's overdue chore
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "User1 Overdue",
                "assigned_to": "user1",
                "current_state": ChoreState.TODO,
                "deadline": (now - timedelta(days=1)).isoformat(),
            }
        )

        # User2's overdue chore
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "User2 Overdue",
                "assigned_to": "user2",
                "current_state": ChoreState.TODO,
                "deadline": (now - timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_overdue_chores(user_id="user1")

        assert len(result) == 1
        assert result[0]["assigned_to"] == "user1"

    async def test_limit_parameter(self, patched_analytics_db):
        """Test limiting number of results returned."""
        now = datetime.now(UTC)

        # Create 5 overdue chores
        for i in range(5):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Overdue {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.TODO,
                    "deadline": (now - timedelta(days=i+1)).isoformat(),
                }
            )

        result = await analytics_service.get_overdue_chores(limit=3)

        assert len(result) == 3

    async def test_sorting_by_deadline(self, patched_analytics_db):
        """Test that overdue chores are sorted by deadline (oldest first)."""
        now = datetime.now(UTC)

        # Create chores with different deadlines
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Most Overdue",
                "assigned_to": "user1",
                "current_state": ChoreState.TODO,
                "deadline": (now - timedelta(days=5)).isoformat(),
            }
        )
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Less Overdue",
                "assigned_to": "user1",
                "current_state": ChoreState.TODO,
                "deadline": (now - timedelta(days=2)).isoformat(),
            }
        )

        result = await analytics_service.get_overdue_chores()

        # Should be sorted oldest deadline first
        assert len(result) == 2
        assert result[0]["title"] == "Most Overdue"
        assert result[1]["title"] == "Less Overdue"


@pytest.mark.unit
class TestGetUserStatistics:
    """Tests for get_user_statistics function."""

    async def test_user_not_found_raises_error(self, patched_analytics_db):
        """Test that requesting stats for non-existent user raises error."""
        with pytest.raises(RecordNotFoundError):
            await analytics_service.get_user_statistics(user_id="nonexistent", period_days=30)

    async def test_user_with_zero_activity(self, patched_analytics_db, sample_users):
        """Test user with no completions or pending claims."""
        # Create user
        user = await patched_analytics_db.create_record("users", {"name": "Alice", "status": UserStatus.ACTIVE})

        result = await analytics_service.get_user_statistics(user_id=user["id"], period_days=30)

        assert result["user_id"] == user["id"]
        assert result["user_name"] == "Alice"
        assert result["completions"] == 0
        assert result["claims_pending"] == 0
        assert result["overdue_chores"] == 0
        assert result["rank"] is None
        assert result["period_days"] == 30

    async def test_user_with_single_pending_claim(self, patched_analytics_db, sample_users):
        """Test user with 1 pending claim."""
        # Create user
        user = await patched_analytics_db.create_record("users", {"name": "Alice", "status": UserStatus.ACTIVE})

        # Create pending verification chore
        chore = await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Pending Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.PENDING_VERIFICATION,
                "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
            }
        )

        # Create claim log for that chore
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": "user1",
                "action": "claimed_completion",
                "chore_id": chore["id"],
                "timestamp": (datetime.now(UTC) - timedelta(hours=1)).isoformat(),
            }
        )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        assert result["claims_pending"] == 1

    async def test_user_with_chunked_pending_claims(self, patched_analytics_db, sample_users):
        """Test user with >50 pending claims (tests chunking logic)."""
        # Create user
        await patched_analytics_db.create_record("users", sample_users[0])

        # Create 60 pending verification chores and claims
        for i in range(60):
            chore = await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Pending Chore {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.PENDING_VERIFICATION,
                    "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
                }
            )

            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user1",
                    "action": "claimed_completion",
                    "chore_id": chore["id"],
                    "timestamp": (datetime.now(UTC) - timedelta(hours=1)).isoformat(),
                }
            )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        # Should count all 60 despite chunking
        assert result["claims_pending"] == 60

    async def test_user_with_many_total_claims_but_few_pending(self, patched_analytics_db, sample_users):
        """Test user with >500 total claim logs but <50 pending claims."""
        # Create user
        await patched_analytics_db.create_record("users", sample_users[0])

        # Create 10 pending verification chores with claims
        for i in range(10):
            chore = await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Pending Chore {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.PENDING_VERIFICATION,
                    "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
                }
            )

            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user1",
                    "action": "claimed_completion",
                    "chore_id": chore["id"],
                    "timestamp": (datetime.now(UTC) - timedelta(hours=1)).isoformat(),
                }
            )

        # Create 100 historical (completed) chores with claims
        for i in range(100):
            chore = await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Historical Chore {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.COMPLETED,
                    "deadline": (datetime.now(UTC) - timedelta(days=10)).isoformat(),
                }
            )

            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user1",
                    "action": "claimed_completion",
                    "chore_id": chore["id"],
                    "timestamp": (datetime.now(UTC) - timedelta(days=11)).isoformat(),
                }
            )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        # Should only count the 10 pending claims, not historical ones
        assert result["claims_pending"] == 10

    async def test_user_with_multiple_claims_same_chore(self, patched_analytics_db, sample_users):
        """Test user with multiple claims for the same chore (edge case)."""
        # Create user
        await patched_analytics_db.create_record("users", sample_users[0])

        # Create 1 pending verification chore
        chore = await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Pending Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.PENDING_VERIFICATION,
                "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
            }
        )

        # Create multiple claim logs for the same chore (unusual but possible)
        for i in range(3):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user1",
                    "action": "claimed_completion",
                    "chore_id": chore["id"],
                    "timestamp": (datetime.now(UTC) - timedelta(hours=i+1)).isoformat(),
                }
            )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        # Should count all 3 claim logs
        assert result["claims_pending"] == 3

    async def test_user_not_in_leaderboard(self, patched_analytics_db, sample_users):
        """Test user with no completions (not in leaderboard)."""
        # Create user
        await patched_analytics_db.create_record("users", sample_users[0])

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        assert result["rank"] is None
        assert result["completions"] == 0

    async def test_user_with_high_rank(self, patched_analytics_db, sample_users):
        """Test user with high rank in leaderboard."""
        # Create users
        for user in sample_users:
            await patched_analytics_db.create_record("users", user)

        now = datetime.now(UTC)

        # User1: 10 completions (rank 1)
        for _ in range(10):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user1",
                    "action": "claimed_completion",
                    "timestamp": (now - timedelta(days=5)).isoformat(),
                }
            )

        # User2: 5 completions (rank 2)
        for _ in range(5):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": "user2",
                    "action": "claimed_completion",
                    "timestamp": (now - timedelta(days=5)).isoformat(),
                }
            )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        assert result["rank"] == 1
        assert result["completions"] == 10

    async def test_user_with_overdue_chores(self, patched_analytics_db, sample_users):
        """Test user with overdue chores assigned."""
        # Create user
        await patched_analytics_db.create_record("users", sample_users[0])

        now = datetime.now(UTC)

        # Create overdue chores
        for i in range(3):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Overdue {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.TODO,
                    "deadline": (now - timedelta(days=i+1)).isoformat(),
                }
            )

        result = await analytics_service.get_user_statistics(user_id="user1", period_days=30)

        assert result["overdue_chores"] == 3


@pytest.mark.unit
class TestGetHouseholdSummary:
    """Tests for get_household_summary function."""

    async def test_empty_household(self, patched_analytics_db):
        """Test household summary with no data."""
        result = await analytics_service.get_household_summary(period_days=7)

        assert result["active_members"] == 0
        assert result["completions_this_period"] == 0
        assert result["current_conflicts"] == 0
        assert result["overdue_chores"] == 0
        assert result["pending_verifications"] == 0
        assert result["period_days"] == 7

    async def test_household_with_active_members(self, patched_analytics_db, sample_users):
        """Test counting active members."""
        # Create active users
        for user in sample_users:
            await patched_analytics_db.create_record("users", user)

        # Create a banned user (non-active)
        await patched_analytics_db.create_record(
            "users",
            {"id": "user4", "name": "Banned Dave", "status": UserStatus.BANNED}
        )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["active_members"] == 3  # Only active users

    async def test_household_with_completions(self, patched_analytics_db):
        """Test counting completions in period."""
        now = datetime.now(UTC)

        # Create completions within period
        for i in range(5):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": f"user{i}",
                    "action": "approve_verification",
                    "timestamp": (now - timedelta(days=3)).isoformat(),
                }
            )

        # Create completion outside period
        await patched_analytics_db.create_record(
            "logs",
            {
                "user_id": "user5",
                "action": "approve_verification",
                "timestamp": (now - timedelta(days=10)).isoformat(),
            }
        )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["completions_this_period"] == 5

    async def test_household_with_conflicts(self, patched_analytics_db):
        """Test counting current conflicts."""
        # Create conflict chores
        for i in range(3):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Conflict {i}",
                    "assigned_to": f"user{i}",
                    "current_state": ChoreState.CONFLICT,
                    "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
                }
            )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["current_conflicts"] == 3

    async def test_household_with_overdue_chores(self, patched_analytics_db):
        """Test counting overdue chores."""
        now = datetime.now(UTC)

        # Create overdue chores
        for i in range(4):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Overdue {i}",
                    "assigned_to": f"user{i}",
                    "current_state": ChoreState.TODO,
                    "deadline": (now - timedelta(days=1)).isoformat(),
                }
            )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["overdue_chores"] == 4

    async def test_household_with_pending_verifications(self, patched_analytics_db):
        """Test counting pending verifications."""
        # Create pending verification chores
        for i in range(6):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Pending {i}",
                    "assigned_to": f"user{i}",
                    "current_state": ChoreState.PENDING_VERIFICATION,
                    "deadline": (datetime.now(UTC) + timedelta(days=1)).isoformat(),
                }
            )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["pending_verifications"] == 6

    async def test_household_full_summary(self, patched_analytics_db, sample_users):
        """Test complete household summary with all data types."""
        # Create users
        for user in sample_users:
            await patched_analytics_db.create_record("users", user)

        now = datetime.now(UTC)

        # Create completions
        for i in range(3):
            await patched_analytics_db.create_record(
                "logs",
                {
                    "user_id": f"user{i}",
                    "action": "approve_verification",
                    "timestamp": (now - timedelta(days=2)).isoformat(),
                }
            )

        # Create conflicts
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Conflict Chore",
                "assigned_to": "user1",
                "current_state": ChoreState.CONFLICT,
                "deadline": (now + timedelta(days=1)).isoformat(),
            }
        )

        # Create overdue chores
        for i in range(2):
            await patched_analytics_db.create_record(
                "chores",
                {
                    "title": f"Overdue {i}",
                    "assigned_to": "user1",
                    "current_state": ChoreState.TODO,
                    "deadline": (now - timedelta(days=1)).isoformat(),
                }
            )

        # Create pending verifications
        await patched_analytics_db.create_record(
            "chores",
            {
                "title": "Pending Chore",
                "assigned_to": "user2",
                "current_state": ChoreState.PENDING_VERIFICATION,
                "deadline": (now + timedelta(days=1)).isoformat(),
            }
        )

        result = await analytics_service.get_household_summary(period_days=7)

        assert result["active_members"] == 3
        assert result["completions_this_period"] == 3
        assert result["current_conflicts"] == 1
        assert result["overdue_chores"] == 2
        assert result["pending_verifications"] == 1
        assert result["period_days"] == 7
